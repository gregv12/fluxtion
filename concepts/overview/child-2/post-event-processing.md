---
description: Post processing for a node after an event process cycle
---

# Post event processing

## Introduction

The goal is to provide nodes a method of resetting state after each event cycle. 

Nodes are effectively memory caches that store intermediate and permanent results of event processing. Child nodes can refer to cached values of parent nodes to perform calculations. Some of the cached values may need resetting at the end of an event cycle, and others are stored permanently. Fluxtion provides two annotations that mark a method for post event cycle processing.

| Annotation | Behaviour |
| :--- | :--- |
| [@AfterEvent](https://github.com/v12technology/fluxtion/blob/master/builder/src/main/java/com/fluxtion/api/annotations/AfterEvent.java) | Marks a method to be called when  event processing has completed. This is for any event regardless if the containing instance is on the execution path. These methods will always be executed after an event cycle. |
| [@OnEventComplete](https://github.com/v12technology/fluxtion/blob/master/builder/src/main/java/com/fluxtion/api/annotations/OnEventComplete.java) | Marks a method to be called when event processing has completed. Only for node instances that are on the active execution path will be invoked.  |

Event post processing methods are invoked in reverse topological order. The SEP will automatically invoke post processing methods after an event cycle.

{% hint style="info" %}
OnEventComplete methods will execute before AfterEvent methods
{% endhint %}

## Example

The example demonstrates both post processing annotations. The code for the example is located [here](https://github.com/v12technology/fluxtion/tree/master/examples/documentation-examples/src/main/java/com/fluxtion/example/core/events/postevent).

### The node classes:

```java
public class ResetAfterEvent {
    
    private final Object parent;
        
    @AfterEvent
    public void afterEvent(){}
}

public class ResetDataEvent {
    private final DataEventHandler handler;
    
    @OnEvent
    public void eventUpdate() {}
    
    @OnEventComplete
    public void dataEventReset(){}
}

public class ResetGlobal {

    private final ResetDataEvent global;

    @EventHandler
    public void conifgUpdate(ConfigEvent cfgEvent){}
    
    @OnEvent
    public void eventUpdate() {}
    
    @AfterEvent
    public void afterEvent(){}
    
    @OnEventComplete
    public void eventComplete(){}
}

```

### Generated SEP

The generated solution implements unique post processing for each event defined with `@OnEventComplete`, located at the end of each event handler method. The final call in the event handler method is to `afterEvent()`, where the `@AfterEvent` methods are invoked.

```java
public class SampleProcessor implements EventHandler, BatchHandler, Lifecycle {

  //Node declarations
  private final DataEventHandler dataEventHandler_1 = new DataEventHandler();
  private final ResetDataEvent resetDataEvent_3 = new ResetDataEvent(dataEventHandler_1);
  private final ResetGlobal resetGlobal_5 = new ResetGlobal(resetDataEvent_3);
  private final ResetAfterEvent resetAfterEvent_7 = new ResetAfterEvent(resetGlobal_5);
  //code omitted for clarity
  
  public void handleEvent(ConfigEvent typedEvent) {
    //Default, no filter methods
    resetGlobal_5.conifgUpdate(typedEvent);
    resetGlobal_5.eventUpdate();
    //event stack unwind callbacks
    resetGlobal_5.eventComplete();
    afterEvent();
  }

  public void handleEvent(DataEvent typedEvent) {
    //Default, no filter methods
    dataEventHandler_1.handleEvent(typedEvent);
    resetDataEvent_3.eventUpdate();
    resetGlobal_5.eventUpdate();
    //event stack unwind callbacks
    resetDataEvent_3.dataEventReset();
    resetGlobal_5.eventComplete();
    afterEvent();
  }

  @Override
  public void afterEvent() {
    resetAfterEvent_7.afterEvent();
    resetGlobal_5.afterEvent();
  }

}

```

### Generated png

The png generated by the Fluxtion ESC.

![Sample SEP demonstrating post event processing](../../../.gitbook/assets/sampleprocessor%20%284%29.png)

