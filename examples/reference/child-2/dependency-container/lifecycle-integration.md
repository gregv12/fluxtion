---
description: Initialise and teardown nodes
---

# Lifecycle integration

## Introduction

The goal is to provide a facility for nodes in the SEP to receive initialise and teardown notifications.

Nodes may want to carry out one-off initialisation before processing events, or release resources if the SEP has completed processing and will receive no more events. Fluxtion provides two annotations that a node can a mark a method with to join the lifecycle callback set.

| Annotation | Behaviour |
| :--- | :--- |
| [@Initialise](https://github.com/v12technology/fluxtion/blob/master/builder/src/main/java/com/fluxtion/api/annotations/Initialise.java) | Invoked before any events are processed. Initialisation methods are invoked in topological order. |
| [@TearDown](https://github.com/v12technology/fluxtion/blob/master/builder/src/main/java/com/fluxtion/api/annotations/TearDown.java) | Invoked after all events have been processed by the SEP. Teardown methods are invoked in reverse topological order. |

## Example

In this example we annotate several classes in a graph with various @Initialise and @TeardDown annotations. The generated SEP implements the lifecycle method callbacks in the init and teardown methods defined in the [Lifecycle](https://github.com/v12technology/fluxtion/blob/master/api/src/main/java/com/fluxtion/runtime/lifecycle/Lifecycle.java) interface.

The code for the example is located [here](https://github.com/v12technology/fluxtion/tree/develop/examples/documentation-examples/src/main/java/com/fluxtion/example/core/dependencyinjection/lifecycle).

### Node classes:

```java
public class CleanListener {
//omitted code for clarity
    @Initialise
    public void init() {}
}

public class DirtyListener {
//omitted code for clarity   
    @TearDown
    public void tearDown() {}
}

public class DirtyCleanCombiner {
//omitted code for clarity   
    private final Object parent1;
    private final Object parent2;
        
    @Initialise
    public void init(){}
    
    @TearDown
    public void tearDown(){}    
}
```

### Generated SEP

The two methods of interest in the SEP are the init and tearDown methods.

{% hint style="warning" %}
Note the generated SEP does not call the lifecycle methods init and tearDown that is the repsonsibility of the application code using the SEP.
{% endhint %}

```java
public class SampleProcessor implements EventHandler, BatchHandler, Lifecycle {

  //Node declarations
  private final ConditioningHandler conditioningHandler_1 = new ConditioningHandler();
  private final CleanListener cleanListener_3 = new CleanListener(conditioningHandler_1);
  private final DirtyCleanCombiner dirtyCleanCombiner_7 =
      new DirtyCleanCombiner(cleanListener_3, cleanListener_3);
  private final DirtyListener dirtyListener_5 = new DirtyListener(conditioningHandler_1);

  //code omitted for clarity

  @Override
  public void init() {
    conditioningHandler_1.init();
    cleanListener_3.init();
    dirtyCleanCombiner_7.init();
  }

  @Override
  public void tearDown() {
    dirtyListener_5.tearDown();
    dirtyCleanCombiner_7.tearDown();
    conditioningHandler_1.tearDown();
  }

}
```

### Generated png

 The graphical representation of this execution graph as generated by Fluxtion ESC:

![Example SEP demonstrating init and teardown lifecycle](../../../../.gitbook/assets/sampleprocessor%20%2813%29.png)

