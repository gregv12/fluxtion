---
description: Be notified when a parent does not notify of change
---

# Clean node conditional branching

## Introduction

The goal is to only let the execution path propagate if a node does not mark itself as being dirty. This is the inverse of [dirty node monitoring](dirty-node-monitoring.md).

Sometimes we want to know if a node did not issue a dirty notification after processing an update. Taking the example of the breach indicator we may want to trigger an execution path branch when the limit is not breached. 

An OnEvent method with a boolean return type is monitored as a dirty status flag by Fluxtion with the following rules:

* A true value marks the node as dirty Fluxtion swallows the event wave and no child OnEvent methods are invoked.
* A false value marks the node as clean and the event wave propagates to child nodes.

The child node indicates it wants to be notified on clean status by adding the dirty = true attribute to its OnEvent annotation: 

```java
@OnEvent(dirty = false)
```

## Example

We create an event handler that issues a change notification flag. We connect three listener to this each with different behaviours depending upon the dirty flag status of the parent. The listeners are:

<table>
  <thead>
    <tr>
      <th style="text-align:left">Node</th>
      <th style="text-align:left">Behaviour</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">DirtyListener</td>
      <td style="text-align:left">changeUpdate() invoked when the parent indicates a change</td>
    </tr>
    <tr>
      <td style="text-align:left">CleanListener</td>
      <td style="text-align:left">noChangeUpdate() invoked when parent indicates no change</td>
    </tr>
    <tr>
      <td style="text-align:left">DirtyCleanListener</td>
      <td style="text-align:left">
        <p>Combines clean and dirty listeners into one class:</p>
        <p>changeUpdate() invoked when the parent indicates a change</p>
        <p>noChangeUpdate() invoked when parent indicates no change</p>
      </td>
    </tr>
  </tbody>
</table>The nodes CleanListener and DirtyCleanListener use the dirty flag = false on the OnEvent annotation to indicate they are interested in receiving clean notifications.

the code for the example is located [here](https://github.com/v12technology/fluxtion/tree/master/examples/documentation-examples/src/main/java/com/fluxtion/example/core/events/clean).

### Node classes

```java
public class CleanListener {

    private final Object parent;
    
    @OnEvent(dirty = false)
    public void noChangeUpdate() {}
}

public class DirtyListener {
   
    private final Object parent;

    @OnEvent
    public void changeUpdate() {} 
}

public class DirtyCleanListener {
       
    private final Object parent;

    @OnEvent
    public void changeUpdate() {} 
    
    @OnEvent(dirty = false)
    public void noChangeUpdate() {}
}
```

### Generated SEP

The dispatch method inverts the return type from the parent node when the child is listening for "clean" parents. As we expect there are four callback methods in the dispatch.

```java
public class SampleProcessor implements EventHandler, BatchHandler, Lifecycle {

  //Node declarations
  private final ConditioningHandler conditioningHandler_1 = new ConditioningHandler();
  private final CleanListener cleanListener_3 = new CleanListener(conditioningHandler_1);
  private final DirtyCleanListener dirtyCleanListener_7 =
      new DirtyCleanListener(conditioningHandler_1);
  private final DirtyListener dirtyListener_5 = new DirtyListener(conditioningHandler_1);
  //Dirty flags
  private boolean isDirty_conditioningHandler_1 = false;
  //Filter constants

  public SampleProcessor() {}

  public void handleEvent(MyEvent typedEvent) {
    //Default, no filter methods
    isDirty_conditioningHandler_1 = conditioningHandler_1.onEvent(typedEvent);
    if (!isDirty_conditioningHandler_1) {
      cleanListener_3.noChangeUpdate();
    }
    if (isDirty_conditioningHandler_1) {
      dirtyCleanListener_7.changeUpdate();
    }
    if (!isDirty_conditioningHandler_1) {
      dirtyCleanListener_7.noChangeUpdate();
    }
    if (isDirty_conditioningHandler_1) {
      dirtyListener_5.changeUpdate();
    }
    //event stack unwind callbacks
    afterEvent();
  }

  @Override
  public void afterEvent() {

    isDirty_conditioningHandler_1 = false;
  }

}
```

### Generated png 

The graphical representation of this execution graph as generated by Fluxtion ESC:

![Sample SEP for clean and dirty listeners](../../../.gitbook/assets/sampleprocessor%20%288%29.png)

